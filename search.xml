<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Ftest%2F</url>
    <content type="text"><![CDATA[## ## ##]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来到阿战的博客。 博客信息本博客建立于2019年1月15日，同时注册域名 51az.top，预祝自己可以越走越高。 博客目的希望将写博客当做记笔记一样，通过写博客将自己学的东西和生活记录下来。 博客平台博客由Hexo驱动，使用NexT主题，部署在GitHub。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法考试]]></title>
    <url>%2FDSAA%2F</url>
    <content type="text"><![CDATA[保佑我数据结构不挂 无向图深度优先搜索 从初始点Vi出发深度优先搜索由邻接矩阵GA表示的图123456789void dfsMatrix(adjmatrix GA, int i, int n, int *visited)&#123; //从初始点Vi出发深度优先搜索由邻接矩阵GA表示的图 int j; printf("%d ",i); visited[i]=1; for(j=0;j&lt;n;j++) if(GA[i][j]!=0 &amp;&amp; GA[i][j]!=MaxValue &amp;&amp; !visited[i]) dfsMatrix(GA,j,n,visited);&#125; 从初始点Vi出发深度优先搜索由邻接表GL表示的图12345678910111213void dfsAdjoin(adjlist GL, int i, int n, int *visited)&#123; //从初始点Vi出发深度优先搜索由邻接表GL表示的图 int j; printf("%d ",i); visited[i]=1; edgenode *p=GL[i]; while(p!=NULL)&#123; j=p-&gt;adjvex; if(!visited[j]) dfsAdjoin(GL,j,n,visited); p=p-&gt;next; &#125;&#125; 二叉树按层遍历1234567891011121314151617181920212223void LevelOrder(BTreeNode *BT)&#123; int MaxSize=30; BTreeNode *q[30]; int front=0,rear=0; BTreeNode *p; if(BT!=NULL)&#123; rear=(rear+1)%MaxSize; q[rear]=BT; &#125; while(front!=rear)&#123; front=(front+1)%MaxSize; p=q[front]; printf("%d ",p-&gt;data); if(p-&gt;left!=NULL)&#123; rear=(rear+1)%MaxSize; q[rear]=p-&gt;left; &#125; if(p-&gt;right!=NULL)&#123; rear=(rear+1)%MaxSize; q[rear]=p-&gt;right; &#125; &#125;&#125; 最小生成树普里姆算法1234567891011121314151617181920212223242526272829void Prim(adjmatrix GA, edgeset CT, int n)&#123; int i,j,k,min,t,m,w; for(i=0;i&lt;n-1;i++)&#123; CT[i].fromvex=0; CT[i].endvex=i+1; CT[i].weight=GA[0][i+1]; &#125; for(k=1;k&lt;n;k++)&#123; min=MaxValue; m=k-1; for(j=k-1;j&lt;n-1;j++) if(CT[j].weight&lt;min)&#123; min=CT[j].weight; m=j; &#125; edge temp=CT[k-1]; CT[k-1]=CT[m]; CT[m]=temp; j=CT[k-1].endvex; for(i=k;i&lt;n-1;i++)&#123; t=CT[i].endvex; w=GA[j][t]; if(w&lt;CT[i].weight)&#123; CT[i].weight=w; CT[i]=fromvex=j; &#125; &#125; &#125;&#125; 克鲁斯卡尔算法123456789101112131415161718192021222324252627282930313233void Kruskal(edgeset GE, edgeset CT, int n)&#123; int i,j; int **s； s=(int**)malloc(n*sizeof(int*)); //第一维 for(i=0;i&lt;n;i++) s[i]=(int*)malloc(i*sizeof(int));//第二维 for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++) if(i==j) s[i][j]=1; else s[i][j]=1; &#125; int k=1; int d=0; int m1,m2; while(k&lt;n)&#123; for(i=0;i&lt;n;i++)&#123; if(s[i][GE[d].fromvex]==ture) m1=i; if(s[i][GE[d].endvex]==ture) m2=i; &#125; if(m1!=m2)&#123; CT[k-1]=GE[d]; k++; for(j=0;j&lt;n;j++)&#123; s[m1][j]=s[m1][j] || s[m2][j]; s[m2][j]=0; &#125; &#125; d++; &#125; for(i=0;i&lt;n;i++) free(s[i]); free(s);&#125; 链栈1234struct SNode&#123; ElemType data; SNode* next;&#125;; 链栈的初始化123void InitSack(struct SNode *HS)&#123; HS=NULL;&#125; 插入一个元素123456void PUsh(struct SNode *HS,ElemType item)&#123; newptr = (struct SNode *)malloc(sizeof(struct SNode)); newptr-&gt;data=item; newptr-&gt;next=HS; HS=newptr;&#125; 从栈顶删除一个元素并返回12345678910111213ElemType Pop(struct SNode *HS)&#123; SNode *p; EleType temp; if(HS==NULL)&#123; printf("Linked stack is empty!\n"); exit(1); &#125; p=HS; HS=HS-&gt;next; temp=p-&gt;data; free(p); return temp;&#125; 读取栈顶元素1234567ElemType PEeek(struct SNode *HS)&#123; if(HS==NULL)&#123; printf("Linked stack is empty!\n"); exit(1); &#125; return HS-&gt;data;&#125; 检查链栈是否为空123int EmptyStack(struct SNode *HS)&#123; return HS==NULL;&#125; 清除链栈为空12345678910void ClearStack(struct SNode *HS)&#123; SNode *cp,*np; cp=HS; while(cp!=NULL)&#123; np=cp-&gt;next; free(cp); cp=np; &#125; HS=NULL;&#125; 哈弗曼树1234567891011121314151617181920212223242526272829303132333435363738394041BTreeNode *CreateHuffman(ElemType a[],int n)&#123; int i,j; int k1=-1,k2; BTreeNode **b,*q; b=(BTreeNode**)malloc(n*sizeof(BTreeNode*)); for(i=0;i&lt;n;i++)&#123; b[i]=(BTreeNode*)malloc(sizeof(BTreeNode)); b[i]-&gt;data=a[i]; b[i]-&gt;left=b[i]-&gt;right=NULL; &#125; for(i=1;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)&#123; if(b[j]!=NULL &amp;&amp; k1==-1)&#123; k1=j; continue; &#125; if(b[j]!=NULL)&#123; k2=j; break; &#125; &#125; for(j=k2;j&lt;n;j++)&#123; if(b[j]!=NULL)&#123; if(b[j]-&gt;data&lt;b[k1]-&gt;data)&#123; k2=k1; k1=j; &#125; else if(b[j]-&gt;data&lt;b[k2]-&gt;data) k2=j; &#125; &#125; q=(BTreeNode*)malloc(sizeof(BTreeNode)); q-&gt;data=b[k1]-&gt;data+b[k2]-&gt;data; q-&gt;left=b[k1]; q-&gt;right=b[k2]; &#125; for(i=0;i&lt;n;i++)&#123; free(b[i]); &#125; free(b); return q;&#125;]]></content>
      <categories>
        <category>Data</category>
      </categories>
      <tags>
        <tag>Data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记（一）]]></title>
    <url>%2Fjava01%2F</url>
    <content type="text"><![CDATA[将曾经用C语言写的一个猜数字小程序转化为java版 C语言代码： 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int main()&#123; int sjsz,answer,i; srand((unsigned)time(NULL)); sjsz=100+rand()%100;//设定随机数字 printf("请在100~200之间猜一个数字%d：",sjsz); for(i=0;i&lt;=4;i++) &#123; scanf("%d",&amp;answer); if(i==4 &amp;&amp; answer!=sjsz) printf("错误次数已达五次，自动结束。"); else &#123; if(answer&gt;sjsz) printf("大了，请重新输入："); if(answer&lt;sjsz) printf("小了，请重新输入："); if(answer==sjsz) &#123; printf("恭喜，回答正确！");break; &#125; &#125; &#125;&#125; Java代码： 1234567891011121314151617181920212223package caishuzi;import java.util.*;// Random、Scanner包含在里面public class c &#123; public static void main(String args[]) &#123; Scanner sc = new Scanner(System.in); Random r = new Random();//创建随机数 int sjsz = r.nextInt(100)+100;//生成一个100~200的随机数 System.out.print("请在100~200之间猜一个数字："+sjsz); for(int i=0;i&lt;=4;i++) &#123; int answer = sc.nextInt(); if(i==4 &amp;&amp; answer!=sjsz) System.out.print("错误次数已达到五次，自动结束。"); else &#123; if(answer&gt;sjsz) System.out.print("大了，请重新输入："); else if(answer&lt;sjsz) System.out.print("小了，请重新输入："); else if(answer==sjsz) &#123; System.out.print("恭喜，回答正确！"); break; &#125; &#125; &#125; &#125;&#125; 在java与c中很多思想都是一样的，循环和判断语句可以直接套用c中的 printf() 需要换为 System.out.print()在创建随机数是需要先new一个Random型的的对象，然后在对象中获取随机数Random r = new Random(); 创建随机数int sjsz = r.nextInt(100)+100; 生成一个100~200的随机数获得键盘输入流也是需要先new一个Scanner型的对象，然后在对象中获取键盘所键入的数据Scanner sc = new Scanner(System.in); new一个Scanner型的对象int answer = sc.nextInt(); 从对象中获得键盘所键入的数据 Java学习的路还很长啊]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活随笔（一）]]></title>
    <url>%2Fnote01%2F</url>
    <content type="text"><![CDATA[最近的生活很是无趣，一天天的准备着二级考试却好似一点进度都没有，分数总还是徘徊在这一块，也总是没有进步，却因为这个二级也好长时间没有写博客了。 我也不知道考完二级下一步是要做什么，是继续学习C/C++，还是学学Python，又或者学学JAVA，进一步学习安卓开发。总是这样什么都想要却什么都得不到，这正是我生活的表现啊。PS教程也好久没看了，想学很久了啊，算算这可能是第三次放弃了，总是有这样那样的借口去逃脱。英语也是这样隔了多少天没看了，自己的行动力和执行力总是欠缺那么多。 生活总是这样的不好过，就像你说你对你的学长已经累了一样，我对你同样的有着很多的无奈，我很期待你的到来，我相信我可以等到你。]]></content>
      <tags>
        <tag>LIFE</tag>
        <tag>NOTE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记课程设计——ATM模拟系统]]></title>
    <url>%2Fatm%2F</url>
    <content type="text"><![CDATA[前言为期两周的课程设计终于结束了，自己也结束了在实验室划水的日子。在这几天里我完成了自己的课程设计ATM模拟系统，这个课程设计主要用到了动态链表和文件。对于链表自己之前是学过的，只是没有用过所以在使用过程中有许多的不熟悉，尤其是在处理文件中读取链表和将链表输出到文件还有历遍链表查找某个数据是否存在等问题时，对头指针和工作指针的把握总是不足。不过，经历了这次的程序设计我感觉我对指针和动态链表的理解越来越深了，对其的运用也越来越熟练了。 解释对于ATM模拟系统的数据储存我首先想到的就是链表与文件，因为一个ATM模拟系统里面的帐号信息是需要储存起来，进行重复使用的，而且帐号的数量也是不定的，所以我决定采用动态链表和文件结合的方式进行设计。在账号信息的构建中我加入了字符串型的用户名username、字符串型的密码password，还有整型的余额balance。整个程序中使用了两个全局变量，一个是动态链表的头指针h，一个是当前用户在链表中所在节点的地址指针s；将头指针作为全局变量是因为整个程序中有三个函数要用到头指针，而这三个函数的关系却又不是那么的密切，在对他们进行调用时需要将头指针在多个函数之间进行传递，所以直接将他们作为全局变量。对于设置新账户、登录和转账这种需要验证一个账号是否存在且要取得该账号的密码和余额等信息，所以我建立了一个查找函数。查找函数用于历遍链表检查某个账号是否存在，如果该账号存在则返回该账号所在节点地址，否则返回空。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#include&lt;Windows.h&gt;typedef struct node &#123;//账户存储节点 char username[18]; char password[18]; int balance; struct node *next;&#125;list;//函数声明void menu_1();//一级菜单void menu_2();//登录后的二级菜单void read();//从文件中读取链表void outlink();//输出链表到文件list* find(char []);//查找某账号是否存在int isnum(char[]);//检测字符串是不是纯数字void take();//取款void save();//存款void transfer();//转账void change();//改密void set();//设置void load();//登录//声明结束//全局变量声明list*h,*s;//链表头、当前用户//声明结束void read() &#123;//启动时读取文件 int r_balance; char r_username[18], r_password[18]; FILE *fp; list *p, *q; h = (list*)malloc(sizeof(list)); p = h; fp = fopen("data.dat", "r");//以只读的形式打开 data.dat if (fp != NULL) &#123; while (fscanf(fp, "%s %s %d", &amp;r_username, &amp;r_password, &amp;r_balance) != EOF) &#123; q = (list*)malloc(sizeof(list)); strcpy(q-&gt;username,r_username); strcpy(q-&gt;password,r_password); q-&gt;balance = r_balance; p-&gt;next = q; p = q; &#125; p-&gt;next = NULL; fclose(fp); &#125; else &#123; fclose(fp); &#125;&#125;void outlink() &#123;//写出链表到文件 FILE *fp; list *p; p = h-&gt;next; fp = fopen("data.dat","w"); while (p)&#123; fprintf(fp, "%s %s %d\n", p-&gt;username, p-&gt;password, p-&gt;balance); p = p-&gt;next; &#125; fclose(fp);&#125;list* find(char fusername[18]) &#123;//查找某个账号是否存在，若存在则返回该账号所在节点地址，否则返回空 list *p,*re;//re为返回值 re = NULL; p = h-&gt;next; while (p != NULL) &#123; if (strcmp(p-&gt;username,fusername)==0) &#123; re = p; break; &#125; else &#123; p = p-&gt;next; &#125; &#125; return re;&#125;int isnum(char s[]) &#123;//检验某字符串是不是由纯数字组成的，是则返回1，否则返回0 int i,re=1; for (i = 0;s[i] != '\0'; i++) &#123; if (s[i]&lt;'0' || s[i]&gt;'9') &#123; re = 0; break; &#125; &#125; return re;&#125;void take() &#123;//取款 int stake;//取款金额 char X;//用于是否继续 printf("\t\t\t\t*尊敬的%s用户，您的余额为：%d。\n", s-&gt;username, s-&gt;balance); printf("\t\t\t\t*请输入您的取款金额："); do &#123; scanf("%d",&amp;stake); if (stake &gt; s-&gt;balance) &#123; printf("\t\t\t\t*取款金额大于您的余额！\n"); printf("\t\t\t\t*请重新输入您的取款金额："); continue; &#125; if (stake &lt; 0) &#123; printf("\t\t\t\t*取款金额不得小于0！\n"); printf("\t\t\t\t*请重新输入您的取款金额："); continue; &#125; if (stake &gt; 2500) &#123; printf("\t\t\t\t*一次取款金额不得大于2500！\n"); printf("\t\t\t\t*请重新输入您的取款金额："); continue; &#125; if (stake % 50 != 0) &#123; printf("\t\t\t\t*只能取出面额为50或100的RMB！\n"); printf("\t\t\t\t*请重新输入您的取款金额："); continue; &#125; &#125; while (stake&gt;2500 || stake%50!=0); printf("\t\t\t\t*您的取款金额为：%d，请输入Y进行确认，输入N返回上一菜单。\n",stake); while (1) &#123; printf("\t\t\t\t*请输入："); //getchar();//起作用 //while ((X = getchar()) != '\n' &amp;&amp; X!= EOF);//不起作用 //fflush(stdin);//不起作用 rewind(stdin);//在此处用于重定向键盘缓冲区 scanf("%c", &amp;X); if (X=='Y') &#123; s-&gt;balance = s-&gt;balance - stake; outlink(); printf("\t\t\t\t*取款成功，返回上一菜单。\n"); Sleep(1500); system("cls"); menu_2(); break; &#125; else if (X == 'N') &#123; system("cls"); menu_2(); break; &#125; &#125;&#125;void save() &#123; int money; char X; printf("\t\t\t\t*尊敬的%s用户，您的余额为：%d。\n", s-&gt;username, s-&gt;balance); printf("\t\t\t\t*请输入您的存款金额："); do &#123; scanf("%d", &amp;money); if (money &lt; 0) &#123; printf("\t\t\t\t*对不起，存款金额不能小于零。\n"); printf("\t\t\t\t*请重新开始你的存款:"); continue; &#125; if (money % 50 != 0) &#123; //判断存款金额是否是50的倍数 printf("\t\t\t\t*对不起，只能识别面值为50或100的钞票。\n"); printf("\t\t\t\t*请重新开始你的存款:"); &#125; &#125; while (money % 50 != 0 || money &lt; 0); printf("\t\t\t\t*您的存款金额为：%d，请输入Y进行确认，输入N返回上一菜单。\n", money); while (1) &#123; printf("\t\t\t\t*请输入："); rewind(stdin); scanf("%c", &amp;X); if (X == 'Y') &#123; s-&gt;balance = s-&gt;balance + money; outlink(); printf("\t\t\t\t*存款成功，您的余额为%d，返回上一菜单。\n", s-&gt;balance); Sleep(1500); system("cls"); menu_2(); break; &#125; else if (X == 'N') &#123; system("cls"); menu_2(); break; &#125; &#125;&#125;void transfer() &#123;//转账 int m; char sss[18]; char X; list *ss; ss = NULL; strcpy(sss,s-&gt;username); printf("\t\t\t\t*尊敬的%s用户，您的余额为：%d。\n", s-&gt;username, s-&gt;balance); while (strcmp(sss,s-&gt;username)==0) &#123; printf("\t\t\t\t*请输入您要转账的帐号："); rewind(stdin); gets(sss); if (strcmp(sss,s-&gt;username)==0) &#123; printf("\t\t\t\t*不可给自己转账！\n"); &#125; &#125; ss = find(sss); while (ss == NULL) &#123; printf("\t\t\t\t*该账号不存在，请重新输入："); rewind(stdin); gets(sss); ss = find(sss); &#125; printf("\t\t\t\t*请输入要转账的金额："); scanf("%d",&amp;m); while (m &lt;0) &#123; printf("\t\t\t\t*转账金额不得小于0！\n"); printf("\t\t\t\t*请重新输入您的转账金额："); scanf("%d", &amp;m); &#125; while (m &gt; s-&gt;balance) &#123; printf("\t\t\t\t*转账金额大于您的余额！\n"); printf("\t\t\t\t*请重新输入您的转账金额："); scanf("%d", &amp;m); &#125; printf("\t\t\t\t*您的转账帐号为：%s，您的转账金额为：%d\n",sss, m); printf("\t\t\t\t*请输入Y进行确认，输入N返回上一菜单。\n"); while (1) &#123; printf("\t\t\t\t*请输入："); rewind(stdin); scanf("%c", &amp;X); if (X == 'Y') &#123; s-&gt;balance = s-&gt;balance - m; ss-&gt;balance = ss-&gt;balance + m; outlink(h); printf("\t\t\t\t*转账成功，返回上一菜单。\n"); Sleep(1500); system("cls"); menu_2(); break; &#125; else if (X == 'N') &#123; system("cls"); menu_2(); break; &#125; &#125;&#125;void change() &#123;//修改密码 char old_password[18], new_password[18]; printf("\t\t\t\t*请输入您的旧密码："); rewind(stdin); gets(old_password); while (strcmp(old_password,s-&gt;password)!=0) &#123;//检查旧密码是否正确 printf("\t\t\t\t*旧密码错误，请重新输入："); rewind(stdin); gets(old_password); &#125; if (strcmp(old_password, s-&gt;password) == 0) &#123; printf("\t\t\t\t*旧密码正确。\n"); printf("\t\t\t\t*请输入您的新密码："); rewind(stdin); gets(new_password); strcpy(s-&gt;password,new_password); outlink(); printf("\t\t\t\t*密码修改成功，新密码为：%s。\n",s-&gt;password ); printf("\t\t\t\t*自动跳转到上一菜单。\n"); Sleep(1500); system("cls"); menu_2(); &#125;&#125;void set() &#123;//设置 char s_username[18], s_password[18]; list*p,*ss,*fin; p = h; fin = NULL; printf("\n\n\n"); printf("\t\t\t\t***************************\n"); printf("\t\t\t\t*请设置纯数字帐号和密码。*\n"); printf("\t\t\t\t*帐号密码不得大于十八位。*\n"); printf("\t\t\t\t***************************\n"); printf("\t\t\t\t*请输入帐号："); rewind(stdin); gets(s_username); while (isnum(s_username)!=1) &#123; printf("\t\t\t\t*帐号格式错误！\n"); printf("\t\t\t\t*请重新输入帐号："); rewind(stdin); gets(s_username); &#125; while (strlen(s_username) &gt;= 18) &#123; printf("\t\t\t\t*帐号位数过多！\n"); printf("\t\t\t\t*请重新输入帐号："); rewind(stdin); gets(s_username); &#125; fin = find(s_username);//查找新账号是否存在 while (fin!=NULL) &#123;//新账号存在 printf("\t\t\t\t*该账号已存在，请重新输入："); rewind(stdin); gets(s_username); fin = find( s_username); &#125; printf("\t\t\t\t***************************\n"); printf("\t\t\t\t*请输入密码："); rewind(stdin); gets(s_password); while (isnum(s_password) != 1) &#123; printf("\t\t\t\t*密码格式错误！\n"); printf("\t\t\t\t*请重新输入密码："); rewind(stdin); gets(s_password); &#125; while (strlen(s_password) &gt;= 18) &#123; printf("\t\t\t\t*密码位数过多！\n"); printf("\t\t\t\t*请重新输入密码："); rewind(stdin); gets(s_password); &#125; ss = (list *)malloc(sizeof(list));// strcpy(ss-&gt;username,s_username); strcpy(ss-&gt;password,s_password); ss-&gt;balance = 0;// ss-&gt;next = p-&gt;next;// p-&gt;next = ss;// s = ss; outlink();//将新链表储存到文件 printf("\t\t\t\t*您的账号为%s,您的密码为%s，即将自动为您登录。\n",s-&gt;username ,s-&gt;password ); Sleep(1500); system("cls"); menu_2();&#125;void load() &#123;//登录 list *fin; char l_username[18], l_password[18]; int f = 0; printf("\n\n\n"); printf("\t\t\t\t****************************\n"); printf("\t\t\t\t*请输入您的帐号密码进行登录*\n"); printf("\t\t\t\t****************************\n"); printf("\t\t\t\t*请输入帐号："); rewind(stdin); gets(l_username); printf("\n\t\t\t\t*请输入密码："); rewind(stdin); gets(l_password); fin = find( l_username);//检查是否存在该账号 while (fin == NULL) &#123;//如果账号不存在 f++; if (f == 3) break; printf("\n\t\t\t\t*帐号密码错误，请重新输入。\n"); printf("\t\t\t\t*请输入帐号："); gets(l_username); printf("\n\t\t\t\t*请输入密码："); gets(l_password); fin = find(l_username); &#125; while (fin != NULL ) &#123;//如果账号存在 if (strcmp(fin-&gt;password,l_password)!=0) &#123;//如果密码不正确 f++; if (f == 3) break; printf("\n\t\t\t\t*帐号密码错误，请重新输入。\n"); printf("\t\t\t\t*请输入帐号："); gets(l_username); printf("\n\t\t\t\t*请输入密码："); gets(l_password); fin = find( l_username); &#125; else &#123;//如果密码正确 system("cls"); s = fin; menu_2(); break; &#125; &#125; if (f == 3) &#123;//如果错误次数达到三次 printf("\n\t\t\t\t*帐号密码错误次数过多，返回上一菜单。\n\n"); Sleep(1500); system("cls"); menu_1(); &#125;&#125;void menu_1() &#123;//一级菜单 int menu1;//menu1用作一级菜单的选择 printf("\t\t\t\t*********************************\n"); printf("\t\t\t\t* ATM模拟系统欢迎您的使用 *\n"); printf("\t\t\t\t*********************************\n"); printf("\t\t\t\t* 菜 单 *\n"); printf("\t\t\t\t*********************************\n"); printf("\t\t\t\t* 1.设置 *\n"); printf("\t\t\t\t* 2.登录 *\n"); printf("\t\t\t\t* 3.退出 *\n"); printf("\t\t\t\t*********************************\n"); printf("\t\t\t\t*请输入&lt;1-3&gt;选择需要实现的功能：*\n"); printf("\t\t\t\t*********************************\n"); system("color 2"); while (1) &#123; printf("\t\t\t\t*请输入："); rewind(stdin); scanf("%d", &amp;menu1); if (1 &lt;= menu1 &lt;= 3) &#123; switch (menu1) &#123; case 1: system("cls"); set(); break; case 2: system("cls"); load(); break; case 3: printf("\t\t\t\t*感谢您的本次使用，下次再见！\n"); exit(0); &#125; &#125; &#125;&#125;void menu_2() &#123;//登录后的二级菜单 int menu2; char X; printf("\t\t\t\t*********************************\n"); printf("\t\t\t\t* 欢迎您使用ATM模拟系统！ *\n"); printf("\t\t\t\t*********************************\n"); printf("\t\t\t\t* 当前账户为：%s\n",s-&gt;username); printf("\t\t\t\t*********************************\n"); printf("\t\t\t\t* 菜 单 *\n"); printf("\t\t\t\t*********************************\n"); printf("\t\t\t\t* 1.查询 *\n"); printf("\t\t\t\t* 2.取款 *\n"); printf("\t\t\t\t* 3.存款 *\n"); printf("\t\t\t\t* 4.转账 *\n"); printf("\t\t\t\t* 5.改密 *\n"); printf("\t\t\t\t* 6.清屏 *\n"); printf("\t\t\t\t* 7.退出 *\n"); printf("\t\t\t\t*********************************\n"); printf("\t\t\t\t*请输入&lt;1-5&gt;选择需要实现的功能：*\n"); printf("\t\t\t\t*********************************\n"); while (1) &#123; printf("\t\t\t\t*请输入："); scanf("%d", &amp;menu2); if (1 &lt;= menu2 &lt;= 5) &#123; switch (menu2) &#123; case 1:printf("\t\t\t\t*尊敬的用户%s，您的余额为：%d。\n",s-&gt;username,s-&gt;balance); break; case 2:take(); break; case 3:save(); break; case 4:transfer(); break; case 5:change(); break; case 6:system("cls"); menu_2(); break; case 7:&#123; printf("\t\t\t\t*请问是否安全退出？（Y/N）\n"); while (1) &#123; printf("\t\t\t\t*请输入："); rewind(stdin); scanf("%c", &amp;X); if (X == 'Y') &#123; s = NULL; system("cls"); menu_1(); break; &#125; else if (X == 'N') &#123; system("cls"); menu_2(); break; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main() &#123; read(); menu_1();&#125;]]></content>
      <categories>
        <category>C Program</category>
        <category>NOTE</category>
      </categories>
      <tags>
        <tag>C Program</tag>
        <tag>NOTE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构基本概念]]></title>
    <url>%2Fthe-data-structure%2F</url>
    <content type="text"><![CDATA[数据结构的定义数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机程序中冰杯计算机程序处理的符号的总称。数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。数据对象：是性质相同的数据元素的集合，是数据的一个子集。数据逻辑结构定义：数据逻辑结构是对数据元素之间逻辑关系的描述，它可以用一个数据元素的集合和定义在此集合中的若干关系来表示。 要素： 数据元素的集合，通常记为D D上的关系，它反映了数据元素之间的前后件关系，通常记为R 数据结构： B=(D,R)其中B表示数据结构。为了反映D中各数据元素之间的前后件关系，一般用二元组来表示。数据的逻辑结构在计算机储存空间中的存放形式称为数据的存储结构（数据的物理结构）。在数据的储存结构在不仅各数据元素的信息，还需要存放各数据元素之间的前后件关系的信息。一种数据的逻辑结构根据需要可以表示成多种存储结构，常用的存储结构有顺序、链接、索引等存储结构。而采用不同的存储结构，其数据处理的效 率是不同的。因 此，在进行数据处理时，选择合适的存储结构是很重 要的。 线性关系与非线性关系根据数据结构中各数据元素之间前后件关系的复杂程度，一般将数据结构分为两大类型：线性结构与非线性结构。 线性结构： 有且只有一个根结点； 每一个结点最多有一个前件，也最多有一个后件。 线性结构又称线性表。在一个线性结构中插入或删除任何一个结点后还应是线性结构。如果一个数据结构不是线性结构，则称之为非线性结构。]]></content>
      <categories>
        <category>C Program</category>
      </categories>
      <tags>
        <tag>Data</tag>
        <tag>C Program</tag>
        <tag>NCRE2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言链表的学习记录]]></title>
    <url>%2Flist-node%2F</url>
    <content type="text"><![CDATA[链表的解释：链表是一种常见的基础数据结构，结构体指针在这里得到了充分的利用。链表可以动态的进行存储分配，也就是说，链表是一个功能极为强大的数组，他可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点。链表都有一个头指针，一般以head来表示，存放的是一个地址。链表中的节点分为两类，头结点和一般节点，头结点是没有数据域的。链表中每个节点都分为两部分，一个数据域，一个是指针域。说到这里你应该就明白了，链表就如同车链子一样，head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。 链表具有的操作：创建、修改、删除、插入、输出、排序、反序、清空链表的元素、求链表的长度等等。 链表的结构：Head—-&gt;[p1]—-&gt;[p2]…—-&gt;[pn]—-&gt;[NULL] 简单的单向链表：12345678910111213141516171819#include&lt;stdio.h&gt;struct node &#123; int date; struct node*next;&#125;;//首先创建结构体int main()&#123; struct node a, b, c,*p;//生命结构体变量a,b,c，并且假设它们是不相邻的 a.date = 10; b.date = 20; c.date = 30;//在结构体变量a,b,c中存放数据 a.next = &amp;b; b.next = &amp;c; c.next = NULL;//在结构体变量中存放下一个结构体变量的地址 p = &amp;a; //结构体变量a地址赋给p while (p) &#123; printf("%d",p-&gt;date ); printf("\n"); p = p-&gt;next; //每输出一个值后，p自动指向本项的链接项 /*这样有了一个单独保持链接的成员就把不相临的存储单元在逻辑上存储在了一起*/ &#125;&#125; 上面形成链表的方法是人为定义的，在程序执行过程中，不会生成新的存储单元，所以也称为“静态链表”。 动态单向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;stdio.h&gt;struct node &#123; int data; struct node*next;&#125;;//首先创建结构体typedef struct node list;//定义变量类型list是node类型的。list*creat_list()&#123;/*该函数的作用是创建动态链表，函数的返回值是结构体指针变量，也就是新创建的动态链表的头结点，需要注意的是，这里的头结点没有数据data，只有指针next指向动态链表的第一个结点*/ int datas;//用来存放结构体中的data list *h, *s, *r;//声明工作指针 h = (list *)malloc(sizeof(list));//动态获取一个结构体的存储空间 r = h;//结构指针r用来使下面的结构指针h不变 printf("创建一个链表输入-1结束：\n"); scanf_s("%d",&amp;datas);//获得结构体成员date 数据 while (datas != -1) &#123;//如果上面得到的int data数据不为-1就进入循环 s = (list *)malloc(sizeof(list));//循环中用结构体指针s获取结点 s-&gt;data = datas;//s成员data为c注意第一次进入循环时，这个c是在循环外部上面输入的 r-&gt;next = s; /*r指针本来与h相同，r的成员next在进入循环前是没有指向的现在进入了循环得到了一个结点， 就把r的next指向新的结点,这样就使h头结点指向了s*/ r = s;//r依次与最新的结点相同，为了依次用最新的存储空间的next指向下一个获得的结点 scanf_s("%d", &amp;datas); &#125; r-&gt;next = '\0';//退出循环后，r指向最后一个结点，而这个最后结点的成员next要指向'\0' return h;//返回动态链表的头结点指针&#125;void print_list(list *head) &#123; /*该函数是依次输出动态链表的结点，参数是结构体指针变量，也就是 动态链表的头结点*/ list *p; /*声明一个工作指针，因为head不能自己往后依次移动，所以用指针p实现*/ p = head-&gt;next; if (p == '\0')printf("Linklist is null!\n");/*空链表*/ else &#123; printf("当前链表为："); printf("head");/*非空链表*/ do &#123; printf("-&gt;%d", p-&gt;data); p = p-&gt;next; &#125; while (p != '\0'); printf("-&gt;end\n"); &#125;&#125;list *insert_snode(list *head, int x, int y) &#123; /*该函数实现在链表值为x的结点前面插入一个结点，值为y参数有三个链表头结点，值x，y*/ list *s, *p, *q; /*定义工作指针*/ s = (list *)malloc(sizeof(list)); s-&gt;data = y; /*上面这两句先获取了一个结构体动态存储空间，并给其成员data赋值为y,但此时该空间并未成为链表的一个结点*/ q = head; p = head-&gt;next; /*上面两句初始化工作指针，就是把工作指针q与head相同，p指向head的next*/ while ((p != '\0') &amp;&amp; (p-&gt;data != x)) &#123; /*这个循环是供查找到值为x的结点所在位置的，需要注意的是这里的并的两个条件位置不能变， 因为只有在p指向不为空的时候才能讨论其data成员值是否为x，否则如果p的指向是空，程序确 要先判断p指向的data是不是x这样会发生地址访问错误，因为p本不指向结点，也就无从谈成员 data，所以判断p指向的data是不是x是不对的*/ q = p; p = p-&gt;next; /*满足循环条件的话，p与q依次后移直到找到值为x的结点或到了链表的尾部*/ &#125; s-&gt;next = p; /*在p指向的结点前面插入，所以新的结点的next指向p*/ q-&gt;next = s; /*q-next本指向p结点,现在令其指向s结点，实现了插入*/ return head;/*头指针并未变化，返回即可*/&#125;list *insert_bnode(list *head, int x, int y) &#123; /*该函数实现在链表值为x的结点后面插入一个结点，值为y参数有三个链表头结点，值x，y*/ list *s, *p, *q; /*定义工作指针*/ s = (list *)malloc(sizeof(list)); s-&gt;data = y; /*上面这两句先获取了一个结构体动态存储空间，并给其成员data赋值为y,但此时该空间并未成为链表的一个结点*/ q = head; p = head-&gt;next; /*上面两句初始化工作指针，就是把工作指针q与head相同,p指向head的next*/ while ((p != '\0') &amp;&amp; (p-&gt;data != x)) &#123; /*这个循环是供查找到值为x的结点所在位置的，需要注意的是这里的并的两个条件位置不能变， 因为只有在p指向不为空的时候才能讨论其data成员值是否为x，否则如果p的指向是空，程序确 要先判断p指向的data是不是x这样会发生地址访问错误，因为p本不指向结点，也就无从谈成员 data，所以判断p指向的data是不是x是不对的*/ q = p; p = p-&gt;next; /*满足循环条件的话，p与q依次后移直到找到值为x的结点或到了链表的尾部*/ &#125; s-&gt;next = p-&gt;next; /*在p指向的结点后面插入，所以新的结点的next指向p*/ p-&gt;next = s; /*p-next本指向p后面的结点,现在令其指向s结点，实现了后插入*/ return head;/*头指针并未变化，返回即可*/&#125;list *del_node(list *head, int x) &#123; /*该函数实现删除链表值为x的结点，参数有两个链表头结点，值x */ list *s, *p, *q; /*定义工作指针*/ q = head; p = head-&gt;next; /*上面两句初始化工作指针，就是把工作指针q与head相同， p指向head的next*/ while ((p != '\0') &amp;&amp; (p-&gt;data != x)) &#123; /*这个循环是供查找到值为x的结点所在位置的，需要注意的是这里的并的两个条件位置不能变， 因为只有在p指向不为空的时候才能讨论其data成员值是否为x，否则如果p的指向是空，程序确 要先判断p指向的data是不是x这样会发生地址访问错误，因为p本不指向结点，也就无从谈成员 data，所以判断p指向的data是不是x是不对的*/ q = p; p = p-&gt;next; /*满足循环条件的话，p与q依次后移直到找到值为x的结点或到了链表的尾部*/ &#125; q-&gt;next = p-&gt;next; /*把q-&gt;next置成p-&gt;next,*/ free(p); /*释放p的存储空间，实现删除*/ return head; /*头指针并未变化，返回即可*/&#125;main() &#123; list *head; int x, y; head = creat_list();//创建链表函数 print_list(head); printf("在x值前面插入y值。"); scanf_s("%d",&amp;x); scanf_s("%d",&amp;y); insert_snode(head,x,y); print_list(head); printf("在x值后面插入y值。"); scanf_s("%d", &amp;x); scanf_s("%d", &amp;y); insert_bnode(head, x, y); print_list(head); printf("删除x值。"); scanf_s("%d", &amp;x); del_node(head, x); print_list(head);&#125;]]></content>
      <categories>
        <category>C Program</category>
      </categories>
      <tags>
        <tag>C Program</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数小记]]></title>
    <url>%2Ffunction%2F</url>
    <content type="text"><![CDATA[isdigit头文件： ctype.h 定义： isdigit(char ch)参数ch是一个char型字符。 功能： 判断char是否为十进制数字字符。 说明： isdigit(char)用来判断char是否为十进制数字字符，若不是，则返回NULL。 isalpha头文件： ctype.h 定义： isalpha(char ch)参数ch是一个char型字符。 功能： 判断char是否为英文字母字符。 说明： isalpha(char)用来判断char是否为英文字母a-z或A-Z时，若不是，则返回NULL。 tolower头文件： stdlib.h 定义： tolower(int ch)参数ch是int型。 功能： 转换给定的字母为小写。 说明： 返回转换后的小写字母，若不须转换则将参数ch 值返回。 toupper头文件： stdlib.h 定义： toupper(int ch)参数ch是int型。 功能： 转换给定的字母为大写。 说明： 返回转换后的大写字母，若不须转换则将参数ch 值返回。]]></content>
      <categories>
        <category>C Program</category>
      </categories>
      <tags>
        <tag>C Program</tag>
        <tag>NCRE2</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法小记]]></title>
    <url>%2Falgorithm%2F</url>
    <content type="text"><![CDATA[算法的复杂度时间复杂度 算法的时间复杂度是指执行算法所需要的计算工作量，既算法执行过程中所需要的基本运算次数，为了能够比较可观的反映出一个算法的效率，在度量一个算法的工作量时，不仅应该与所使用的计算机、程序设计语言以及程序编制者无感，而且还应该与算法实现过程中许多细节无关。 空间复杂度 算法在运行过程中需辅助储存空间的大小成为算法的空间复杂度。]]></content>
      <categories>
        <category>C Program</category>
      </categories>
      <tags>
        <tag>C Program</tag>
        <tag>Algorithm</tag>
        <tag>NCRE2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言中 b? x:y]]></title>
    <url>%2Fc-b-x-y%2F</url>
    <content type="text"><![CDATA[b?x:y是C语言中唯一一个三目运算符（条件运算符）。一般表达式： 表达式1？表达式2：表达式3 执行顺序：如果表达式1值非0（为真）则执行表达式2，此时表达式2的值作为整个表达式的值；如果表达式1的值为0则执行表达式3，此时表达式3的值作为整个表达式的值例如：max=（a&gt;b）?a:b,执行结果就是将a和b中大者赋给max。（条件运算符的优先级高于赋值运算，低于关系运算和算术运算）例子：输出a，b中较大者 12345678#include&lt;stdio.h&gt;int main (void)&#123;int a,b;scanf("%d%d",&amp;a,&amp;b);printf("%d\n",a&gt;b?a:b);return 0;&#125;]]></content>
      <categories>
        <category>C Program</category>
      </categories>
      <tags>
        <tag>C Program</tag>
        <tag>NCRE2</tag>
      </tags>
  </entry>
</search>
